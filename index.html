<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ultimate Anime Post Generator</title>
    <style>
        :root {
            --bg-color: #121212;
            --surface-color: #1e1e1e;
            --primary-color: #9c27b0; /* Vibrant Purple */
            --primary-variant-color: #7b1fa2;
            --text-color: #e0e0e0;
            --text-secondary-color: #a0a0a0;
            --border-color: #333;
        }
        * { box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            margin: 0;
            padding: 15px;
            background-color: var(--bg-color);
            color: var(--text-color);
        }
        .container {
            max-width: 1000px;
            margin: auto;
            background: var(--surface-color);
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 8px 30px rgba(0,0,0,0.3);
            border: 1px solid var(--border-color);
        }
        .page { display: none; }
        .page.active { display: block; animation: fadeIn 0.5s ease-in-out; }
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }

        h1, h2, h3 { color: var(--primary-color); text-align: center; border-bottom: 1px solid var(--border-color); padding-bottom: 10px; margin-top: 0; }

        /* General UI Elements */
        .btn {
            padding: 12px 20px; font-size: 16px; color: white; border: none;
            border-radius: 8px; cursor: pointer; text-align: center;
            font-weight: bold; transition: background-color 0.3s, transform 0.2s;
        }
        .btn:hover { transform: translateY(-2px); }
        .btn-sm { padding: 5px 10px; font-size: 12px; }
        .btn-primary { background-color: var(--primary-color); }
        .btn-primary:hover { background-color: var(--primary-variant-color); }
        .btn-secondary { background-color: #6c757d; }
        .btn-success { background-color: #28a745; }
        
        input, select, textarea {
            width: 100%; padding: 12px; font-size: 14px;
            background-color: #2a2a2a; color: var(--text-color);
            border: 1px solid var(--border-color); border-radius: 8px;
        }
        input:focus, select:focus, textarea:focus {
            outline: none; border-color: var(--primary-color);
        }
        .input-group { display: flex; gap: 10px; margin-bottom: 10px; }
        .input-group input { flex-grow: 1; }


        /* Page 1: Search */
        .search-container { display: flex; gap: 10px; margin-bottom: 20px; }
        #searchResults { display: grid; grid-template-columns: repeat(auto-fill, minmax(140px, 1fr)); gap: 20px; margin-top: 20px; }
        .result-card { cursor: pointer; text-align: center; transition: transform 0.2s, box-shadow 0.2s; background: #2a2a2a; padding: 10px; border-radius: 8px; }
        .result-card:hover { transform: scale(1.05); box-shadow: 0 0 15px rgba(156, 39, 176, 0.5); }
        .result-card img { width: 100%; border-radius: 6px; }
        .result-card p { font-weight: 600; margin-top: 8px; font-size: 14px; color: var(--text-secondary-color); }

        #import-section { margin-top: 30px; padding-top: 20px; border-top: 1px solid var(--border-color); }
        #import-section textarea { height: 150px; margin-bottom: 10px; }


        /* Page 2: Details */
        #details-header { display: flex; gap: 20px; margin-bottom: 20px; align-items: flex-start; }
        #details-header img { max-width: 180px; border-radius: 8px; }
        #details-info h2 { text-align: left; border-bottom: none; display: inline-block; margin-right: 10px; }
        #details-info p { font-size: 15px; line-height: 1.6; color: var(--text-secondary-color); }
        
        #episode-list .episode-row {
            display: grid; grid-template-columns: auto 1fr 1fr 2fr auto; gap: 10px; align-items: center;
            margin-bottom: 10px; padding: 10px; background-color: #2a2a2a; border-radius: 8px;
        }
        .episode-row span { font-weight: bold; }
        .episode-row .remove-btn { background: #dc3545; color: white; border: none; cursor: pointer; width: 30px; height: 30px; border-radius: 50%; font-weight: bold; font-size: 16px; line-height: 1; }
        
        #output-section { margin-top: 30px; }
        #postOutput { height: 400px; font-family: monospace; background-color: #0d0d0d; color: #a9b7c6; }
        .loader { border: 4px solid var(--border-color); border-top: 4px solid var(--primary-color); border-radius: 50%; width: 30px; height: 30px; animation: spin 1s linear infinite; margin: 20px auto; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        /* Mobile Adjustments */
        @media (max-width: 768px) {
            body { padding: 10px; }
            #details-header { flex-direction: column; align-items: center; text-align: center; }
            #details-info h2 { text-align: center; }
            #episode-list .episode-row { grid-template-columns: 1fr 1fr; grid-template-rows: auto auto auto; }
            .episode-row span { grid-column: 1 / 3; }
            .episode-row input[placeholder*="Title"] { grid-column: 1 / 3; }
            .episode-row .remove-btn { grid-row: 2; grid-column: 2; justify-self: end; }
        }
    </style>
</head>
<body>

<div class="container">
    <!-- Page 1: Search -->
    <div id="search-page" class="page active">
        <h1>Anime Post Generator</h1>
        <div class="search-container">
            <input type="text" id="searchInput" placeholder="Enter anime title..." onkeyup="if(event.keyCode===13) searchAnime()">
            <button id="searchBtn" class="btn btn-primary" onclick="searchAnime()">Search</button>
        </div>
        <div id="loader" class="loader" style="display: none;"></div>
        <div id="searchResults"></div>

        <!-- ADDED: Import Section -->
        <div id="import-section">
            <h3>অথবা আগের পোস্ট এডিট করুন</h3>
            <textarea id="importData" placeholder="এখানে আগের পোস্টের সম্পূর্ণ HTML কোড পেস্ট করুন..."></textarea>
            <button class="btn btn-secondary" style="width:100%;" onclick="importPost()">পোস্ট লোড করুন</button>
        </div>
    </div>

    <!-- Page 2: Details and Episode Input -->
    <div id="details-page" class="page">
        <button class="btn btn-secondary" style="margin-bottom:20px;" onclick="showPage('search-page')">&larr; Back to Search</button>
        <div id="details-header">
            <img id="details-poster" src="" alt="Anime Poster">
            <div id="details-info">
                <div>
                    <h2 id="details-title"></h2>
                    <!-- ADDED: Copy Title Button -->
                    <button class="btn btn-secondary btn-sm" onclick="copyTitle()">Copy</button>
                </div>
                <p id="details-synopsis"></p>
            </div>
        </div>
        
        <h3>Add Episodes</h3>
        <div id="episode-list"></div>
        <button class="btn btn-primary" style="margin-bottom:20px;" onclick="addEpisodeInput()">+ Add Episode</button>
        
        <!-- MODIFIED: Label Input with Copy Button -->
        <label for="labels">Blogger Labels:</label>
        <div class="input-group">
            <input type="text" id="labels" placeholder="Labels will be auto-generated here...">
            <button class="btn btn-secondary" onclick="copyLabels()">Copy</button>
        </div>
        
        <button class="btn btn-success" style="width:100%; margin-top: 20px;" onclick="generatePost()">Generate Post Code</button>

        <div id="output-section" style="display:none;">
            <textarea id="postOutput" readonly></textarea>
            <button class="btn btn-primary" style="width:100%; margin-top: 10px;" onclick="copyToClipboard()">Copy Post Code</button>
        </div>
    </div>
</div>

<script>
    const API_URL = 'https://graphql.anilist.co';
    let selectedAnimeData = null;
    let episodeCounter = 0;

    function showPage(pageId) {
        document.querySelectorAll('.page').forEach(page => page.classList.remove('active'));
        document.getElementById(pageId).classList.add('active');
        if (pageId === 'search-page') {
            document.getElementById('searchResults').innerHTML = '';
            document.getElementById('searchInput').value = '';
            document.getElementById('importData').value = '';
        }
    }

    async function apiRequest(query, variables) {
        document.getElementById('loader').style.display = 'block';
        try {
            const response = await fetch(API_URL, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json', 'Accept': 'application/json' },
                body: JSON.stringify({ query, variables })
            });
            if (!response.ok) throw new Error('Network response was not ok');
            return await response.json();
        } catch (error) {
            console.error('API Request Failed:', error);
            alert('Failed to fetch data from AniList. Please try again.');
        } finally {
            document.getElementById('loader').style.display = 'none';
        }
    }

    async function searchAnime() {
        const query = document.getElementById('searchInput').value.trim();
        if (!query) return;
        const searchQuery = `
        query ($search: String) {
            Page (page: 1, perPage: 12) {
                media (search: $search, type: ANIME, sort: SEARCH_MATCH) { id, title { romaji, english }, coverImage { large } }
            }
        }`;
        const data = await apiRequest(searchQuery, { search: query });
        const resultsContainer = document.getElementById('searchResults');
        resultsContainer.innerHTML = '';
        if (data && data.data && data.data.Page.media) {
            data.data.Page.media.forEach(anime => {
                const card = document.createElement('div');
                card.className = 'result-card';
                card.onclick = () => selectAnime(anime.id);
                card.innerHTML = `<img src="${anime.coverImage.large}" alt="${anime.title.romaji}"><p>${anime.title.english || anime.title.romaji}</p>`;
                resultsContainer.appendChild(card);
            });
        }
    }

    async function selectAnime(id) {
        const detailsQuery = `
        query ($id: Int) {
            Media (id: $id, type: ANIME) {
                id, title { romaji, english, native }, synonyms, description(asHtml: false), countryOfOrigin,
                studios(isMain: true) { nodes { name } }, episodes, duration, averageScore, status,
                coverImage { extraLarge }, genres, season, seasonYear
            }
        }`;
        const data = await apiRequest(detailsQuery, { id });
        if (data && data.data) {
            selectedAnimeData = data.data.Media;
            populateDetailsPage();
            showPage('details-page');
        }
    }
    
    function populateDetailsPage() {
        if (!selectedAnimeData) return;
        document.getElementById('details-title').innerText = selectedAnimeData.title.english || selectedAnimeData.title.romaji;
        document.getElementById('details-poster').src = selectedAnimeData.coverImage.extraLarge;
        document.getElementById('details-synopsis').innerText = selectedAnimeData.description.replace(/<br\s*\/?>/gi, ' ');
        document.getElementById('episode-list').innerHTML = '';
        document.getElementById('output-section').style.display = 'none';
        episodeCounter = 0;
        addEpisodeInput();
        generateAndSetLabels();
    }

    // MODIFIED: addEpisodeInput can now receive data to pre-fill inputs
    function addEpisodeInput(title = '', server = 'Rumble', url = '', lang = 'sub') {
        episodeCounter++;
        const row = document.createElement('div');
        row.className = 'episode-row';
        row.id = `episode-row-${episodeCounter}`;
        const epTitle = title || `Episode ${episodeCounter}`;
        
        row.innerHTML = `
            <span>${episodeCounter}.</span>
            <input type="text" placeholder="Episode Title" value="${epTitle}">
            <input type="text" placeholder="Server Name" value="${server}">
            <input type="text" placeholder="Embed URL" value="${url}">
            <select> 
                <option value="sub" ${lang === 'sub' ? 'selected' : ''}>SUB</option> 
                <option value="dub" ${lang === 'dub' ? 'selected' : ''}>DUB</option> 
            </select>
            <button class="remove-btn" onclick="removeEpisodeInput(${episodeCounter})">&times;</button>
        `;
        document.getElementById('episode-list').appendChild(row);
    }
    
    function removeEpisodeInput(id) { 
        document.getElementById(`episode-row-${id}`).remove();
        // Re-number episodes visually
        const rows = document.querySelectorAll('#episode-list .episode-row');
        rows.forEach((row, index) => {
            row.querySelector('span').innerText = `${index + 1}.`;
        });
    }
    
    // MODIFIED: Label generation format changed
    function generateAndSetLabels() {
        if (!selectedAnimeData) return;
        let labels = new Set();
        labels.add('Series');
        selectedAnimeData.genres.forEach(g => labels.add(g));
        if (selectedAnimeData.averageScore) labels.add((selectedAnimeData.averageScore / 10).toFixed(1));
        if (selectedAnimeData.status === 'RELEASING') labels.add('Ongoing');
        if (selectedAnimeData.countryOfOrigin === 'KR') labels.add('Korea');
        labels.add('TV').add('HD').add('Label Baru').add('Genre Baru');
        if (selectedAnimeData.season) {
            const season = selectedAnimeData.season.charAt(0).toUpperCase() + selectedAnimeData.season.slice(1).toLowerCase();
            labels.add(`${season} ${selectedAnimeData.seasonYear}`);
        }
        
        document.getElementById('labels').value = Array.from(labels).join(',');
    }

    function generatePost() {
        if (!selectedAnimeData) return;
        
        const episodes = [];
        let hasSub = false, hasDub = false;
        document.querySelectorAll('.episode-row').forEach((row, index) => {
            const inputs = row.querySelectorAll('input, select');
            const title = inputs[0].value.trim(), server = inputs[1].value.trim(), url = inputs[2].value.trim(), lang = inputs[3].value;
            if (title && url && server) {
                episodes.push({ title, server, url, lang, episode: index + 1 });
                if (lang === 'sub') hasSub = true;
                if (lang === 'dub') hasDub = true;
            }
        });
        if (episodes.length === 0) return alert('Please add at least one episode.');

        let finalLabels = new Set(document.getElementById('labels').value.split(',').filter(l => l.trim() !== ''));
        if(hasSub) finalLabels.add('Sub');
        if(hasDub) finalLabels.add('Dub');
        finalLabels.add(`Ep ${episodes.length}/${selectedAnimeData.episodes || '?'}`);
        const finalLabelsString = Array.from(finalLabels).join(',');
        document.getElementById('labels').value = finalLabelsString;
        
        const streamingFilesString = episodes.map(ep => `  { 'title': '${ep.title.replace(/'/g, "\\'")}', 'episode': '${ep.episode}', 'files': [{ 0: '${ep.server}', 1: '${ep.url}', 2: '${ep.lang}' }] }`).join(',\n');
        const mainTitle = selectedAnimeData.title.english || selectedAnimeData.title.romaji;
        const firstSentence = selectedAnimeData.description ? selectedAnimeData.description.split('. ')[0].replace(/<br\s*\/?>/gi, '') + '.' : 'Click to see synopsis.';
        const synopsisHTML = selectedAnimeData.description ? selectedAnimeData.description.replace(/<br\s*\/?>/gi, '\n').split('\n').filter(p => p.trim() !== '').map(p => `    <p>\n      ${p.trim()}\n    </p>`).join('\n') : '';

        // ADDED: Labels and AniList ID as comments for easy import later
        const postHTML = `<!-- Blogger_Labels: ${finalLabelsString} -->\n<!-- AniList_ID: ${selectedAnimeData.id} -->\n<!-- [ Synopsis ] -->\n<div id="synopsis">\n  <details>\n    <summary>${firstSentence}</summary>\n${synopsisHTML}\n  </details>\n</div>\n<span><a name='more'></a></span>\n<!-- [ Thumbnail ] -->\n<div class="separator" style="clear: both;">\n  <a href="${selectedAnimeData.coverImage.extraLarge}" style="display: block; padding: 1em 0px; text-align: center;">\n    <img alt="${mainTitle.replace(/"/g, '&quot;')}" border="0" data-original-height="1280" data-original-width="720" height="200" src="${selectedAnimeData.coverImage.extraLarge}" />\n  </a>\n</div>\n<!-- [ Streaming Section ] -->\n<script>\nlet streamingFiles = [\n${streamingFilesString}\n],\nstreamingId = '${mainTitle.replace(/'/g, "\\'")}',\npostId = '${Date.now()}',\nmaxEpisode = '${selectedAnimeData.episodes || episodes.length}';\n<\/script>\n<!-- [ Extra Information ] -->\n<dl id="extra-info">\n  <dt>Romaji:</dt><dd>${selectedAnimeData.title.romaji || 'N/A'}</dd>\n  <dt>Native:</dt><dd>${selectedAnimeData.title.native || 'N/A'}</dd>\n  <dt>Synonyms:</dt><dd>${selectedAnimeData.synonyms.join(', ') || 'N/A'}</dd>\n  <dt>Studios:</dt><dd>${selectedAnimeData.studios.nodes.length > 0 ? selectedAnimeData.studios.nodes[0].name : 'N/A'}</dd>\n  <dt>Episodes Duration:</dt><dd>${selectedAnimeData.duration ? selectedAnimeData.duration + ' min per ep' : 'N/A'}</dd>\n  <dt>Rating:</dt><dd>AniList Score: ${selectedAnimeData.averageScore ? (selectedAnimeData.averageScore / 10).toFixed(2) : 'N/A'} / 10</dd>\n</dl>\n<!-- [ Related Post ] -->\n<script>const labelListBS = '${mainTitle.split(':')[0].replace(/'/g, "\\'")}';<\/script>\n<!-- [ Seasons ] -->\n<section class="os-list" data-jumlah="10" data-label="Series/${mainTitle.replace(/"/g, '&quot;')}"></section>`;

        document.getElementById('postOutput').value = postHTML;
        document.getElementById('output-section').style.display = 'block';
    }

    // NEW: Function to import and parse existing post code
    async function importPost() {
        const postHTML = document.getElementById('importData').value;
        if (!postHTML.trim()) return alert('Please paste the post code first.');

        // 1. Extract AniList ID
        const idMatch = postHTML.match(/<!--\s*AniList_ID:\s*(\d+)\s*-->/);
        if (!idMatch || !idMatch[1]) {
            return alert('Could not find AniList ID in the code. Cannot import.');
        }
        const animeId = parseInt(idMatch[1], 10);
        
        // 2. Fetch anime data using the ID
        await selectAnime(animeId);

        // Wait for selectAnime to finish and populate selectedAnimeData
        if (!selectedAnimeData || selectedAnimeData.id !== animeId) {
            return alert('Failed to load anime data for the given post.');
        }

        // 3. Extract Labels
        const labelsMatch = postHTML.match(/<!--\s*Blogger_Labels:\s*(.*?)\s*-->/);
        if (labelsMatch && labelsMatch[1]) {
            document.getElementById('labels').value = labelsMatch[1];
        }

        // 4. Extract Episodes
        const streamingFilesMatch = postHTML.match(/let streamingFiles = \[([\s\S]*?)\],/);
        if (streamingFilesMatch && streamingFilesMatch[1]) {
            const episodesString = streamingFilesMatch[1].trim();
            const episodeRegex = /\{\s*'title':\s*'(.*?)',\s*'episode':\s*'.*?',\s*'files':\s*\[\{\s*0:\s*'(.*?)',\s*1:\s*'(.*?)',\s*2:\s*'(.*?)'\s*\}\]\s*\}/g;
            
            let match;
            const episodes = [];
            while ((match = episodeRegex.exec(episodesString)) !== null) {
                episodes.push({
                    title: match[1].replace(/\\'/g, "'"),
                    server: match[2],
                    url: match[3],
                    lang: match[4]
                });
            }

            // 5. Populate episode list
            if (episodes.length > 0) {
                document.getElementById('episode-list').innerHTML = ''; // Clear the default one
                episodeCounter = 0; // Reset counter
                episodes.forEach(ep => {
                    addEpisodeInput(ep.title, ep.server, ep.url, ep.lang);
                });
            }
        }
        showPage('details-page');
    }

    // MODIFIED: copyToClipboard uses modern clipboard API
    async function copyToClipboard(elementId, successMessage) {
        try {
            const textToCopy = document.getElementById(elementId).value;
            await navigator.clipboard.writeText(textToCopy);
            alert(successMessage);
        } catch (err) {
            console.error('Failed to copy: ', err);
            // Fallback for older browsers
            document.getElementById(elementId).select();
            document.execCommand('copy');
            alert(successMessage);
        }
    }
    
    // ADDED: Specific copy functions for new buttons
    function copyTitle() {
        const title = document.getElementById('details-title').innerText;
        navigator.clipboard.writeText(title).then(() => {
            alert('Anime title copied to clipboard!');
        });
    }

    function copyLabels() {
        copyToClipboard('labels', 'Labels copied to clipboard!');
    }
    
    // Overwrite the old copy function to call the new one
    function copyPostCode() {
         copyToClipboard('postOutput', 'HTML code copied to clipboard!');
    }
    // Rename the function call in the button's onclick to avoid conflicts
    document.querySelector('#output-section button').setAttribute('onclick', 'copyPostCode()');

</script>

</body>
</html>